{"remainingRequest":"/Users/rfarrer/repos/collapse/node_modules/docz-core/node_modules/babel-loader/lib/index.js?{\"presets\":[\"@babel/preset-flow\",\"@babel/preset-react\",[\"/Users/rfarrer/repos/collapse/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":true,\"typescript\":false,\"parseProps\":true}]],\"plugins\":[\"@babel/plugin-syntax-object-rest-spread\",\"@babel/plugin-proposal-class-properties\",\"react-flow-props-to-prop-types\",[\"/Users/rfarrer/repos/collapse/node_modules/docz-utils/lib/named-asset-import.js\",{\"loaderMap\":{\"svg\":{\"ReactComponent\":\"@svgr/webpack?-prettier,-svgo![path]\"}}}],\"/Users/rfarrer/repos/collapse/node_modules/react-hot-loader/babel.js\"],\"cacheDirectory\":true,\"babelrc\":false}!/Users/rfarrer/repos/collapse/src/Collapse.js","dependencies":[{"path":"/Users/rfarrer/repos/collapse/src/Collapse.js","mtime":1540699652989},{"path":"/Users/rfarrer/repos/collapse/node_modules/cache-loader/dist/cjs.js","mtime":1540683830849},{"path":"/Users/rfarrer/repos/collapse/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1539563296618}],"contextDependencies":[],"result":["(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { PureComponent } from 'react'; // Helper function for render props. Sets a function to be called, plus any additional functions passed in\n\nvar callAll = function callAll() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn && fn.apply(void 0, args);\n    });\n  };\n};\n\n// Start animation helper using nested requestAnimationFrames\nvar startAnimationHelper = function startAnimationHelper(callback) {\n  requestAnimationFrame(function () {\n    requestAnimationFrame(function () {\n      callback();\n    });\n  });\n};\n\nvar Collapse =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(Collapse, _PureComponent);\n\n  function Collapse() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Collapse);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Collapse)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      height: _this.props.collapsedHeight,\n      overflow: _this.getIsOpen({\n        isOpen: _this.props.defaultOpen\n      }) ? '' : 'hidden',\n      isOpen: _this.getIsOpen({\n        isOpen: _this.props.defaultOpen\n      }),\n      counter: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"collapsible\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"content\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"timeoutID\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"toggleIsOpen\", function () {\n      return _this.setState(function (_ref) {\n        var isOpen = _ref.isOpen;\n        return {\n          isOpen: !isOpen\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getTogglerProps\", function () {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        onClick: function onClick() {}\n      };\n      return _objectSpread({\n        id: \"CollapseToggle-\".concat(_this.state.counter),\n        'aria-controls': \"CollapsePanel-\".concat(_this.state.counter),\n        'aria-expanded': Boolean(_this.getIsOpen()),\n        tabIndex: 0\n      }, props, {\n        onClick: callAll(props.onClick, _this.toggleIsOpen)\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getCollapsibleProps\", function () {\n      var _objectSpread2;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        refKey: 'ref'\n      };\n      return _objectSpread({\n        id: \"CollapsePanel-\".concat(_this.state.counter),\n        'aria-hidden': Boolean(_this.getIsOpen())\n      }, props, (_objectSpread2 = {}, _defineProperty(_objectSpread2, props.refKey, callAll(_this.assignCollapsibleRef, props[props.refKey])), _defineProperty(_objectSpread2, \"style\", {\n        height: _this.state.height,\n        overflow: _this.state.overflow,\n        willChange: 'height',\n        transition: \"height \".concat(_this.props.duration, \"ms \").concat(_this.props.easing, \" \").concat(_this.props.delay, \"ms\")\n      }), _objectSpread2));\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"assignCollapsibleRef\", function (node) {\n      return _this.collapsible = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"assignContentRef\", function (node) {\n      return _this.content = node;\n    });\n\n    return _this;\n  }\n\n  _createClass(Collapse, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Iterate counter to create unique IDs for each instance of this component\n      // on the page. Used mainly for `aria-` relationships\n      this.setState({\n        counter: Collapse.counter++\n      }); // If open by default, update the height\n\n      if (this.getIsOpen()) {\n        this.setState(this.setOpen());\n      }\n    } // componentDidUpdate(prevProps: Props, prevState: State) {\n    //   const isCurrentlyOpen = this.getIsOpen();\n    //   if (this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen) {\n    //     if (isCurrentlyOpen) {\n    //       this.setOpen();\n    //     } else {\n    //       this.setClosed();\n    //     }\n    //   }\n    // }\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          delay = _this$props.delay,\n          duration = _this$props.duration;\n      var isCurrentlyOpen = this.getIsOpen(); // Check if 'height' prop has changed\n\n      if (this.content && this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen) {\n        // Cache content height\n        this.content.style.overflow = 'hidden';\n        var style = window.getComputedStyle(this.content);\n        var marginTop = style.getPropertyValue('margin-top');\n        var marginBottom = style.getPropertyValue('margin-bottom');\n        var contentHeight = this.content.offsetHeight + marginTop + marginBottom;\n        this.content.style.overflow = ''; // set total animation time\n\n        var totalDuration = duration + delay;\n        var newHeight = null;\n        var timeoutState = {\n          height: null,\n          // it will be always set to either 'auto' or specific number\n          overflow: 'hidden'\n        };\n        var isCurrentHeightAuto = prevState.height === 'auto';\n\n        if (isCurrentlyOpen) {\n          // If new height is a number\n          newHeight = 0;\n          timeoutState.height = newHeight;\n        } else {\n          // If not, animate to content height\n          // and then reset to auto\n          newHeight = contentHeight;\n          timeoutState.height = 'auto';\n          timeoutState.overflow = null;\n        }\n\n        if (isCurrentHeightAuto) {\n          // This is the height to be animated to\n          timeoutState.height = newHeight; // If previous height was 'auto'\n          // set starting height explicitly to be able to use transition\n\n          newHeight = contentHeight;\n        }\n\n        debugger; // Set starting height and animating classes\n        // We are safe to call set state as it will not trigger infinite loop\n        // because of the \"height !== prevProps.height\" check\n\n        this.setState({\n          height: newHeight,\n          overflow: 'hidden',\n          // When animating from 'auto' we first need to set fixed height\n          // that change should be animated\n          shouldUseTransitions: !isCurrentHeightAuto\n        }); // Clear timeouts\n\n        clearTimeout(this.timeoutID);\n\n        if (isCurrentHeightAuto) {\n          // When animating from 'auto' we use a short timeout to start animation\n          // after setting fixed height above\n          timeoutState.shouldUseTransitions = true;\n          startAnimationHelper(function () {\n            _this2.setState(timeoutState);\n          }); // Set static classes and remove transitions when animation ends\n\n          this.timeoutID = setTimeout(function () {\n            _this2.setState({\n              shouldUseTransitions: false\n            }); // ANIMATION ENDS\n            // Hide content if height is 0 (to prevent tabbing into it)\n            // this.hideContent(timeoutState.height);\n\n          }, totalDuration);\n        } else {\n          // Set end height, classes and remove transitions when animation is complete\n          this.timeoutID = setTimeout(function () {\n            timeoutState.shouldUseTransitions = false;\n\n            _this2.setState(timeoutState); // ANIMATION ENDS\n            // If height is auto, don't hide the content\n            // (case when element is empty, therefore height is 0)\n            // if (height !== 'auto') {\n            //   // Hide content if height is 0 (to prevent tabbing into it)\n            //   this.hideContent(newHeight); // TODO solve newHeight = 0\n            // }\n\n          }, totalDuration);\n        }\n      }\n    }\n  }, {\n    key: \"getIsOpen\",\n\n    /**\n     * Returns the state of the isOpen prop.\n     * If it is controlled, return the prop value.\n     * If is isn't, use internal state\n     */\n    value: function getIsOpen() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n      return props.isOpen !== null ? props.isOpen : state.isOpen;\n    } // setOpen = () => ({\n    //   height: this.content ? this.content.clientHeight : 'auto'\n    // });\n    // setOpen = () => {\n    //   // Clear timeouts\n    //   clearTimeout(this.timeoutID);\n    //   const contentHeight = this.content.offsetHeight;\n    //   const totalDuration = this.props.duration + this.props.delay;\n    //   this.setState({height: contentHeight});\n    //   // Set static classes and remove transitions when animation ends\n    //   this.timeoutID = setTimeout(() => {\n    //     debugger;\n    //     this.setState({height: 'auto'});\n    //   }, totalDuration + 1000);\n    // };\n    // setClosed = () => ({height: this.props.collapsedHeight});\n    // setClosed = () => {\n    //   // Clear timeouts\n    //   debugger;\n    //   const contentHeight = this.content.offsetHeight;\n    //   const totalDuration = this.props.duration + this.props.delay;\n    //   this.setState({height: contentHeight}, () => this.setState({height: 0}));\n    //   // startAnimationHelper(() => {\n    //   //   this.setState({height: contentHeight});\n    //   // });\n    //   // Set static classes and remove transitions when animation ends\n    //   // this.timeoutID = setTimeout(() => {\n    //   //   return {height: 0};\n    //   // }, totalDuration);\n    // };\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      console.log(this.state.height);\n      return this.props.children({\n        isOpen: Boolean(this.getIsOpen()),\n        getTogglerProps: this.getTogglerProps,\n        getCollapsibleProps: this.getCollapsibleProps,\n        contentRef: this.assignContentRef\n      });\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return Collapse;\n}(PureComponent);\n\n_defineProperty(Collapse, \"defaultProps\", {\n  isOpen: null,\n  defaultOpen: false,\n  collapsedHeight: 0,\n  duration: 1000,\n  delay: 0,\n  easing: 'ease',\n  shouldUseTransitions: false\n});\n\n_defineProperty(Collapse, \"counter\", 0);\n\nexport { Collapse as default };\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(callAll, \"callAll\", \"/Users/rfarrer/repos/collapse/src/Collapse.js\");\n  reactHotLoader.register(startAnimationHelper, \"startAnimationHelper\", \"/Users/rfarrer/repos/collapse/src/Collapse.js\");\n  reactHotLoader.register(Collapse, \"Collapse\", \"/Users/rfarrer/repos/collapse/src/Collapse.js\");\n  leaveModule(module);\n})();\n\n;\nCollapse.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"getIsOpen\",\n    \"docblock\": \"Returns the state of the isOpen prop.\\nIf it is controlled, return the prop value.\\nIf is isn't, use internal state\",\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"state\"\n    }, {\n      \"name\": \"props\"\n    }],\n    \"returns\": null,\n    \"description\": \"Returns the state of the isOpen prop.\\nIf it is controlled, return the prop value.\\nIf is isn't, use internal state\"\n  }, {\n    \"name\": \"toggleIsOpen\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"getTogglerProps\",\n    \"docblock\": \"At the end of the transition open, make the height of the collapible 'auto'.\\nThis will prevent overflow and height issues if the content of the collapsible\\nchanges while the panel is open\",\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"props\"\n    }],\n    \"returns\": null,\n    \"description\": \"At the end of the transition open, make the height of the collapible 'auto'.\\nThis will prevent overflow and height issues if the content of the collapsible\\nchanges while the panel is open\"\n  }, {\n    \"name\": \"getCollapsibleProps\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"props\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"assignCollapsibleRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": {\n        \"name\": \"HTMLElement\",\n        \"nullable\": true\n      }\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"assignContentRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": {\n        \"name\": \"HTMLElement\",\n        \"nullable\": true\n      }\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"Collapse\",\n  \"props\": {\n    \"isOpen\": {\n      \"defaultValue\": {\n        \"value\": \"null\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"boolean\",\n        \"nullable\": true\n      },\n      \"description\": \"\"\n    },\n    \"defaultOpen\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"boolean\"\n      },\n      \"description\": \"\"\n    },\n    \"collapsedHeight\": {\n      \"defaultValue\": {\n        \"value\": \"0\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"number\"\n      },\n      \"description\": \"\"\n    },\n    \"duration\": {\n      \"defaultValue\": {\n        \"value\": \"1000\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"number\"\n      },\n      \"description\": \"\"\n    },\n    \"delay\": {\n      \"defaultValue\": {\n        \"value\": \"0\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"number\"\n      },\n      \"description\": \"\"\n    },\n    \"easing\": {\n      \"defaultValue\": {\n        \"value\": \"'ease'\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"string\"\n      },\n      \"description\": \"\"\n    },\n    \"shouldUseTransitions\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"required\": false\n    },\n    \"children\": {\n      \"required\": true,\n      \"flowType\": {\n        \"name\": \"signature\",\n        \"type\": \"function\",\n        \"raw\": \"({\\n  isOpen: boolean,\\n  getTogglerProps: (*) => {},\\n  getCollapsibleProps: (*) => {},\\n  contentRef: Ref<*>\\n}) => Node\",\n        \"signature\": {\n          \"arguments\": [{\n            \"name\": \"\",\n            \"type\": {\n              \"name\": \"signature\",\n              \"type\": \"object\",\n              \"raw\": \"{\\n  isOpen: boolean,\\n  getTogglerProps: (*) => {},\\n  getCollapsibleProps: (*) => {},\\n  contentRef: Ref<*>\\n}\",\n              \"signature\": {\n                \"properties\": [{\n                  \"key\": \"isOpen\",\n                  \"value\": {\n                    \"name\": \"boolean\",\n                    \"required\": true\n                  }\n                }, {\n                  \"key\": \"getTogglerProps\",\n                  \"value\": {\n                    \"name\": \"signature\",\n                    \"type\": \"function\",\n                    \"raw\": \"(*) => {}\",\n                    \"signature\": {\n                      \"arguments\": [{\n                        \"name\": \"\",\n                        \"type\": {\n                          \"name\": \"unknown\"\n                        }\n                      }],\n                      \"return\": {\n                        \"name\": \"signature\",\n                        \"type\": \"object\",\n                        \"raw\": \"{}\",\n                        \"signature\": {\n                          \"properties\": []\n                        }\n                      }\n                    },\n                    \"required\": true\n                  }\n                }, {\n                  \"key\": \"getCollapsibleProps\",\n                  \"value\": {\n                    \"name\": \"signature\",\n                    \"type\": \"function\",\n                    \"raw\": \"(*) => {}\",\n                    \"signature\": {\n                      \"arguments\": [{\n                        \"name\": \"\",\n                        \"type\": {\n                          \"name\": \"unknown\"\n                        }\n                      }],\n                      \"return\": {\n                        \"name\": \"signature\",\n                        \"type\": \"object\",\n                        \"raw\": \"{}\",\n                        \"signature\": {\n                          \"properties\": []\n                        }\n                      }\n                    },\n                    \"required\": true\n                  }\n                }, {\n                  \"key\": \"contentRef\",\n                  \"value\": {\n                    \"name\": \"Ref\",\n                    \"elements\": [{\n                      \"name\": \"unknown\"\n                    }],\n                    \"raw\": \"Ref<*>\",\n                    \"required\": true\n                  }\n                }]\n              }\n            }\n          }],\n          \"return\": {\n            \"name\": \"Node\"\n          }\n        }\n      },\n      \"description\": \"\"\n    }\n  }\n};",{"version":3,"sources":["/Users/rfarrer/repos/collapse/src/Collapse.js"],"names":["PureComponent","callAll","fns","args","forEach","fn","startAnimationHelper","callback","requestAnimationFrame","Collapse","height","props","collapsedHeight","overflow","getIsOpen","isOpen","defaultOpen","counter","setState","onClick","id","state","Boolean","tabIndex","toggleIsOpen","refKey","assignCollapsibleRef","willChange","transition","duration","easing","delay","node","collapsible","content","setOpen","prevProps","prevState","isCurrentlyOpen","style","window","getComputedStyle","marginTop","getPropertyValue","marginBottom","contentHeight","offsetHeight","totalDuration","newHeight","timeoutState","isCurrentHeightAuto","shouldUseTransitions","clearTimeout","timeoutID","setTimeout","console","log","children","getTogglerProps","getCollapsibleProps","contentRef","assignContentRef"],"mappings":"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","sourcesContent":["// @flow\n\nimport {PureComponent, type Node, type Ref} from 'react';\n\n// Helper function for render props. Sets a function to be called, plus any additional functions passed in\nconst callAll = (...fns) => (...args: Array<*>) =>\n  fns.forEach(fn => fn && fn(...args));\n\ntype Props = {\n  children: ({\n    isOpen: boolean,\n    getTogglerProps: (*) => {},\n    getCollapsibleProps: (*) => {},\n    contentRef: Ref<*>\n  }) => Node,\n  isOpen: ?boolean,\n  defaultOpen: boolean,\n  collapsedHeight: number,\n  duration: number,\n  easing: string,\n  delay: number\n};\n\ntype State = {\n  height: number | string,\n  isOpen: ?boolean,\n  counter: number\n};\n\n// Start animation helper using nested requestAnimationFrames\nconst startAnimationHelper = (callback: () => {}) => {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      callback();\n    });\n  });\n};\n\nexport default class Collapse extends PureComponent<Props, State> {\n  static defaultProps = {\n    isOpen: null,\n    defaultOpen: false,\n    collapsedHeight: 0,\n    duration: 1000,\n    delay: 0,\n    easing: 'ease',\n    shouldUseTransitions: false\n  };\n\n  static counter = 0;\n\n  state = {\n    height: this.props.collapsedHeight,\n    overflow: this.getIsOpen({isOpen: this.props.defaultOpen}) ? '' : 'hidden',\n    isOpen: this.getIsOpen({isOpen: this.props.defaultOpen}),\n    counter: 0\n  };\n\n  componentDidMount() {\n    // Iterate counter to create unique IDs for each instance of this component\n    // on the page. Used mainly for `aria-` relationships\n    this.setState({counter: Collapse.counter++});\n\n    // If open by default, update the height\n    if (this.getIsOpen()) {\n      this.setState(this.setOpen());\n    }\n  }\n\n  // componentDidUpdate(prevProps: Props, prevState: State) {\n  //   const isCurrentlyOpen = this.getIsOpen();\n\n  //   if (this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen) {\n  //     if (isCurrentlyOpen) {\n  //       this.setOpen();\n  //     } else {\n  //       this.setClosed();\n  //     }\n  //   }\n  // }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {delay, duration} = this.props;\n    const isCurrentlyOpen = this.getIsOpen();\n    // Check if 'height' prop has changed\n    if (\n      this.content &&\n      this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen\n    ) {\n      // Cache content height\n      this.content.style.overflow = 'hidden';\n      var style = window.getComputedStyle(this.content);\n      var marginTop = style.getPropertyValue('margin-top');\n      var marginBottom = style.getPropertyValue('margin-bottom');\n      const contentHeight =\n        this.content.offsetHeight + marginTop + marginBottom;\n      this.content.style.overflow = '';\n\n      // set total animation time\n      const totalDuration = duration + delay;\n\n      let newHeight = null;\n      const timeoutState = {\n        height: null, // it will be always set to either 'auto' or specific number\n        overflow: 'hidden'\n      };\n      const isCurrentHeightAuto = prevState.height === 'auto';\n\n      if (isCurrentlyOpen) {\n        // If new height is a number\n        newHeight = 0;\n        timeoutState.height = newHeight;\n      } else {\n        // If not, animate to content height\n        // and then reset to auto\n        newHeight = contentHeight;\n        timeoutState.height = 'auto';\n        timeoutState.overflow = null;\n      }\n\n      if (isCurrentHeightAuto) {\n        // This is the height to be animated to\n        timeoutState.height = newHeight;\n\n        // If previous height was 'auto'\n        // set starting height explicitly to be able to use transition\n        newHeight = contentHeight;\n      }\n\n      debugger;\n\n      // Set starting height and animating classes\n      // We are safe to call set state as it will not trigger infinite loop\n      // because of the \"height !== prevProps.height\" check\n      this.setState({\n        height: newHeight,\n        overflow: 'hidden',\n        // When animating from 'auto' we first need to set fixed height\n        // that change should be animated\n        shouldUseTransitions: !isCurrentHeightAuto\n      });\n\n      // Clear timeouts\n      clearTimeout(this.timeoutID);\n\n      if (isCurrentHeightAuto) {\n        // When animating from 'auto' we use a short timeout to start animation\n        // after setting fixed height above\n        timeoutState.shouldUseTransitions = true;\n\n        startAnimationHelper(() => {\n          this.setState(timeoutState);\n        });\n\n        // Set static classes and remove transitions when animation ends\n        this.timeoutID = setTimeout(() => {\n          this.setState({\n            shouldUseTransitions: false\n          });\n\n          // ANIMATION ENDS\n          // Hide content if height is 0 (to prevent tabbing into it)\n          // this.hideContent(timeoutState.height);\n        }, totalDuration);\n      } else {\n        // Set end height, classes and remove transitions when animation is complete\n        this.timeoutID = setTimeout(() => {\n          timeoutState.shouldUseTransitions = false;\n\n          this.setState(timeoutState);\n\n          // ANIMATION ENDS\n          // If height is auto, don't hide the content\n          // (case when element is empty, therefore height is 0)\n          // if (height !== 'auto') {\n          //   // Hide content if height is 0 (to prevent tabbing into it)\n          //   this.hideContent(newHeight); // TODO solve newHeight = 0\n          // }\n        }, totalDuration);\n      }\n    }\n  }\n\n  collapsible: ?HTMLElement;\n  content: ?HTMLElement;\n  timeoutID: TimeoutID;\n\n  /**\n   * Returns the state of the isOpen prop.\n   * If it is controlled, return the prop value.\n   * If is isn't, use internal state\n   */\n  getIsOpen(\n    state: $Shape<State> = this.state,\n    props: $Shape<Props> = this.props\n  ) {\n    return props.isOpen !== null ? props.isOpen : state.isOpen;\n  }\n\n  // setOpen = () => ({\n  //   height: this.content ? this.content.clientHeight : 'auto'\n  // });\n\n  // setOpen = () => {\n  //   // Clear timeouts\n  //   clearTimeout(this.timeoutID);\n  //   const contentHeight = this.content.offsetHeight;\n  //   const totalDuration = this.props.duration + this.props.delay;\n  //   this.setState({height: contentHeight});\n\n  //   // Set static classes and remove transitions when animation ends\n  //   this.timeoutID = setTimeout(() => {\n  //     debugger;\n  //     this.setState({height: 'auto'});\n  //   }, totalDuration + 1000);\n  // };\n\n  // setClosed = () => ({height: this.props.collapsedHeight});\n\n  // setClosed = () => {\n  //   // Clear timeouts\n  //   debugger;\n  //   const contentHeight = this.content.offsetHeight;\n  //   const totalDuration = this.props.duration + this.props.delay;\n  //   this.setState({height: contentHeight}, () => this.setState({height: 0}));\n  //   // startAnimationHelper(() => {\n  //   //   this.setState({height: contentHeight});\n  //   // });\n\n  //   // Set static classes and remove transitions when animation ends\n  //   // this.timeoutID = setTimeout(() => {\n  //   //   return {height: 0};\n  //   // }, totalDuration);\n  // };\n\n  toggleIsOpen = () => this.setState(({isOpen}) => ({isOpen: !isOpen}));\n\n  /**\n   * At the end of the transition open, make the height of the collapible 'auto'.\n   * This will prevent overflow and height issues if the content of the collapsible\n   * changes while the panel is open\n   */\n  // handleCollapsibleTransitionEnd = () => {\n  //   if (this.collapsible && this.collapsible.clientHeight !== 0) {\n  //     startAnimationHelper(this.setState({height: 'auto'}));\n  //   }\n  // };\n\n  getTogglerProps = (props: {onClick: ?() => void} = {onClick() {}}) => {\n    return {\n      id: `CollapseToggle-${this.state.counter}`,\n      'aria-controls': `CollapsePanel-${this.state.counter}`,\n      'aria-expanded': Boolean(this.getIsOpen()),\n      tabIndex: 0,\n      ...props,\n      onClick: callAll(props.onClick, this.toggleIsOpen)\n    };\n  };\n\n  getCollapsibleProps = (props: {refKey: string} = {refKey: 'ref'}) => {\n    return {\n      id: `CollapsePanel-${this.state.counter}`,\n      'aria-hidden': Boolean(this.getIsOpen()),\n      ...props,\n      [props.refKey]: callAll(this.assignCollapsibleRef, props[props.refKey]),\n      style: {\n        height: this.state.height,\n        overflow: this.state.overflow,\n        willChange: 'height',\n        transition: `height ${this.props.duration}ms ${this.props.easing} ${\n          this.props.delay\n        }ms`\n      }\n    };\n  };\n\n  assignCollapsibleRef = (node: ?HTMLElement) => (this.collapsible = node);\n\n  assignContentRef = (node: ?HTMLElement) => (this.content = node);\n\n  render() {\n    console.log(this.state.height);\n    return this.props.children({\n      isOpen: Boolean(this.getIsOpen()),\n      getTogglerProps: this.getTogglerProps,\n      getCollapsibleProps: this.getCollapsibleProps,\n      contentRef: this.assignContentRef\n    });\n  }\n}\n"]}]}
{"remainingRequest":"/Users/rfarrer/repos/collapse/node_modules/docz-core/node_modules/babel-loader/lib/index.js?{\"presets\":[\"@babel/preset-flow\",\"@babel/preset-react\",[\"/Users/rfarrer/repos/collapse/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":true,\"typescript\":false,\"parseProps\":true}]],\"plugins\":[\"@babel/plugin-syntax-object-rest-spread\",\"@babel/plugin-proposal-class-properties\",\"react-flow-props-to-prop-types\",[\"/Users/rfarrer/repos/collapse/node_modules/docz-utils/lib/named-asset-import.js\",{\"loaderMap\":{\"svg\":{\"ReactComponent\":\"@svgr/webpack?-prettier,-svgo![path]\"}}}],\"/Users/rfarrer/repos/collapse/node_modules/react-hot-loader/babel.js\"],\"cacheDirectory\":true,\"babelrc\":false}!/Users/rfarrer/repos/collapse/src/Collapse.js","dependencies":[{"path":"/Users/rfarrer/repos/collapse/src/Collapse.js","mtime":1541037574692},{"path":"/Users/rfarrer/repos/collapse/node_modules/cache-loader/dist/cjs.js","mtime":1540683830849},{"path":"/Users/rfarrer/repos/collapse/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1539563296618}],"contextDependencies":[],"result":["(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { PureComponent } from 'react';\nimport RAF from 'raf'; // Helper function for render props. Sets a function to be called, plus any additional functions passed in\n\nvar callAll = function callAll() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn && fn.apply(void 0, args);\n    });\n  };\n};\n\n// Start animation helper using nested requestAnimationFrames\nvar startAnimationHelper = function startAnimationHelper(callback) {\n  requestAnimationFrame(function () {\n    requestAnimationFrame(function () {\n      callback();\n    });\n  });\n};\n\nvar Collapse =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(Collapse, _PureComponent);\n\n  function Collapse() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Collapse);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Collapse)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      // height: this.props.collapsedHeight,\n      // overflow: this.getIsOpen({isOpen: this.props.defaultOpen}) ? '' : 'hidden',\n      styles: {// display: 'block',\n        // height: 'auto',\n        // overflow: 'visible'\n      },\n      isOpen: _this.getIsOpen({\n        isOpen: _this.props.defaultOpen\n      }),\n      isOpening: null,\n      counter: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"transition\", function () {\n      // Determine current state - closing or opening\n      // If opening to 'auto'\n      var _this$props = _this.props,\n          delay = _this$props.delay,\n          duration = _this$props.duration;\n\n      var isCurrentlyOpen = _this.getIsOpen();\n\n      if (isCurrentlyOpen) {\n        // Animate closed\n        var height = _this.getCollapsibleHeight();\n\n        return Promise.resolve().then(function () {\n          return _this.setStyles({\n            height: height\n          }).then(function () {\n            _this.setState({\n              isOpening: 'closing'\n            });\n\n            debugger;\n            return RAF(function () {\n              return _this.setStyles({\n                height: 0,\n                overflow: 'hidden'\n              });\n            });\n          });\n        });\n      } else {\n        // Animate open\n        return Promise.resolve().then(function () {\n          return _this.setStyles({\n            display: 'block',\n            overflow: 'hidden'\n          }).then(function () {\n            var height = _this.getCollapsibleHeight();\n\n            _this.setState({\n              isOpening: 'opening'\n            });\n\n            return _this.setStyles({\n              height: height\n            });\n          });\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getCollapsibleHeight\", function () {\n      if (!_this.collapsible) {\n        return 'auto';\n      }\n\n      return _this.collapsible.scrollHeight;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"measure\", function () {\n      var isCurrentlyOpen = _this.getIsOpen(); // If closed, styles should be {overflow: 'hidden', display: 'none', height: 0}\n\n\n      if (!isCurrentlyOpen) {\n        _this.setStyles({\n          display: 'block',\n          overflow: 'hidden'\n        }).then(function () {\n          var height = _this.getCollapsibleHeight();\n\n          _this.setStyles({\n            height: height\n          });\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setStyles\", function (newStyles) {\n      return new Promise(function (resolve) {\n        var check = function check() {\n          _this.setState(function (_ref) {\n            var styles = _ref.styles;\n            return {\n              styles: _objectSpread({}, styles, newStyles)\n            };\n          }, function () {\n            RAF(function () {\n              if (Object.keys(newStyles).some(function (key) {\n                var newStyle = newStyles[key];\n\n                if (_this.collapsible && _this.collapsible.style[key].includes('px')) {\n                  newStyle = newStyles[key] || newStyles[key] === 0 ? \"\".concat(newStyles[key], \"px\") : '';\n                }\n\n                return !_this.collapsible || _this.collapsible.style[key] !== newStyle;\n              })) {\n                return check();\n              }\n\n              resolve();\n            });\n          });\n        };\n\n        check();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleTransitionEnd\", function () {\n      if (_this.state.isOpening === 'opening') {\n        debugger;\n\n        _this.setState(function (prevState) {\n          return {\n            isOpening: null,\n            styles: _objectSpread({}, prevState.styles, {\n              display: '',\n              overflow: '',\n              height: 'auto'\n            })\n          };\n        });\n      }\n\n      if (_this.state.isOpening === 'closing') {\n        debugger;\n\n        _this.setState(function (prevState) {\n          return {\n            isOpening: null,\n            styles: _objectSpread({}, prevState.styles, {\n              display: 'none'\n            })\n          };\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"collapsible\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"content\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"timeoutID\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"toggleIsOpen\", function () {\n      return _this.setState(function (_ref2) {\n        var isOpen = _ref2.isOpen;\n        return {\n          isOpen: !isOpen\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getTogglerProps\", function () {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        onClick: function onClick() {}\n      };\n      return _objectSpread({\n        id: \"CollapseToggle-\".concat(_this.state.counter),\n        'aria-controls': \"CollapsePanel-\".concat(_this.state.counter),\n        'aria-expanded': Boolean(_this.getIsOpen()),\n        tabIndex: 0\n      }, props, {\n        onClick: callAll(props.onClick, _this.toggleIsOpen)\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getCollapsibleProps\", function () {\n      var _objectSpread2;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        refKey: 'ref'\n      };\n      console.log(props);\n\n      var refKey = props.refKey,\n          others = _objectWithoutProperties(props, [\"refKey\"]);\n\n      debugger;\n      return _objectSpread({\n        id: \"CollapsePanel-\".concat(_this.state.counter),\n        'aria-hidden': Boolean(_this.getIsOpen())\n      }, others, (_objectSpread2 = {}, _defineProperty(_objectSpread2, refKey, callAll(_this.assignCollapsibleRef, others[refKey])), _defineProperty(_objectSpread2, \"onTransitionEnd\", _this.handleTransitionEnd), _defineProperty(_objectSpread2, \"style\", _objectSpread({}, _this.state.styles, {\n        transition: \"height \".concat(_this.props.duration, \"ms \").concat(_this.props.easing, \" \").concat(_this.props.delay, \"ms\")\n      })), _objectSpread2));\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"assignCollapsibleRef\", function (node) {\n      return _this.collapsible = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"assignContentRef\", function (node) {\n      return _this.content = node;\n    });\n\n    return _this;\n  }\n\n  _createClass(Collapse, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Iterate counter to create unique IDs for each instance of this component\n      // on the page. Used mainly for `aria-` relationships\n      this.setState({\n        counter: Collapse.counter++\n      }); // If open by default, update the height\n      // this.transition();\n    } // componentDidUpdate(prevProps: Props, prevState: State) {\n    //   const {delay, duration} = this.props;\n    //   const isCurrentlyOpen = this.getIsOpen();\n    //   // Check if 'height' prop has changed\n    //   if (\n    //     this.content &&\n    //     this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen\n    //   ) {\n    //     // Cache content height\n    //     var style = window.getComputedStyle(this.content);\n    //     var marginTop = style.getPropertyValue('margin-top');\n    //     var marginBottom = style.getPropertyValue('margin-bottom');\n    //     const contentHeight =\n    //       this.content.offsetHeight +\n    //       parseInt(marginTop.split('p')[0], 10) +\n    //       parseInt(marginBottom.split('p')[0], 10);\n    //     // set total animation time\n    //     const totalDuration = duration + delay;\n    //     let newHeight = null;\n    //     const timeoutState = {\n    //       height: null // it will be always set to either 'auto' or specific number\n    //     };\n    //     const isCurrentHeightAuto = prevState.height === 'auto';\n    //     if (isCurrentlyOpen) {\n    //       // If new height is a number\n    //       newHeight = 0;\n    //       timeoutState.height = newHeight;\n    //     } else {\n    //       // If not, animate to content height\n    //       // and then reset to auto\n    //       newHeight = contentHeight;\n    //       timeoutState.height = 'auto';\n    //     }\n    //     if (isCurrentHeightAuto) {\n    //       // This is the height to be animated to\n    //       timeoutState.height = newHeight;\n    //       // If previous height was 'auto'\n    //       // set starting height explicitly to be able to use transition\n    //       newHeight = contentHeight;\n    //     }\n    //     RAF(() =>\n    //       this.setState({\n    //         height: newHeight\n    //       })\n    //     );\n    //     // Clear timeouts\n    //     console.log(timeoutState);\n    //     if (isCurrentHeightAuto) {\n    //       RAF(() => {\n    //         this.setState(timeoutState);\n    //       });\n    //     } else {\n    //       clearTimeout(this.timeoutID);\n    //       this.timeoutID = setTimeout(() => {\n    //         RAF(() => this.setState(timeoutState));\n    //       }, totalDuration);\n    //     }\n    //   }\n    // }\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var isCurrentlyOpen = this.getIsOpen(); // Check if 'height' prop has changed\n      // if (\n      //   this.collapsible &&\n      //   this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen\n      // ) {\n      //   debugger;\n      //   this.setState({isOpening: 'opening'});\n      // } else {\n      //   debugger;\n      //   this.setState({isOpening: 'closing'});\n      // }\n\n      if (this.collapsible && this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen) {\n        this.transition();\n      }\n    } // getTransitionDimensions = () => {\n    //   // Cache content height\n    //   const style = window.getComputedStyle(this.content);\n    //   const marginTop = style.getPropertyValue('margin-top');\n    //   const marginBottom = style.getPropertyValue('margin-bottom');\n    //   const contentHeight =\n    //     this.content.offsetHeight +\n    //     parseInt(marginTop.split('p')[0], 10) +\n    //     parseInt(marginBottom.split('p')[0], 10);\n    //   return {\n    //     contentHeight,\n    //     totalDuration: this.props.delay + this.props.duration\n    //   };\n    // };\n\n  }, {\n    key: \"getIsOpen\",\n\n    /**\n     * Returns the state of the isOpen prop.\n     * If it is controlled, return the prop value.\n     * If is isn't, use internal state\n     */\n    value: function getIsOpen() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n      return props.isOpen !== null ? props.isOpen : state.isOpen;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      console.log(this.state.styles);\n      return this.props.children({\n        isOpen: Boolean(this.getIsOpen()),\n        getTogglerProps: this.getTogglerProps,\n        getCollapsibleProps: this.getCollapsibleProps\n      });\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return Collapse;\n}(PureComponent);\n\n_defineProperty(Collapse, \"defaultProps\", {\n  isOpen: null,\n  defaultOpen: false,\n  collapsedHeight: 0,\n  duration: 1000,\n  delay: 0,\n  easing: 'ease',\n  shouldUseTransitions: false\n});\n\n_defineProperty(Collapse, \"counter\", 0);\n\nexport { Collapse as default };\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(callAll, \"callAll\", \"/Users/rfarrer/repos/collapse/src/Collapse.js\");\n  reactHotLoader.register(startAnimationHelper, \"startAnimationHelper\", \"/Users/rfarrer/repos/collapse/src/Collapse.js\");\n  reactHotLoader.register(Collapse, \"Collapse\", \"/Users/rfarrer/repos/collapse/src/Collapse.js\");\n  leaveModule(module);\n})();\n\n;\nCollapse.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"transition\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"getCollapsibleHeight\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"measure\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"setStyles\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"newStyles\",\n      \"type\": {\n        \"name\": \"signature\",\n        \"type\": \"object\",\n        \"raw\": \"{\\n  height?: number | string,\\n  overflow?: string,\\n  display?: string\\n}\",\n        \"signature\": {\n          \"properties\": [{\n            \"key\": \"height\",\n            \"value\": {\n              \"name\": \"union\",\n              \"raw\": \"number | string\",\n              \"elements\": [{\n                \"name\": \"number\"\n              }, {\n                \"name\": \"string\"\n              }],\n              \"required\": false\n            }\n          }, {\n            \"key\": \"overflow\",\n            \"value\": {\n              \"name\": \"string\",\n              \"required\": false\n            }\n          }, {\n            \"key\": \"display\",\n            \"value\": {\n              \"name\": \"string\",\n              \"required\": false\n            }\n          }]\n        },\n        \"alias\": \"Styles\"\n      }\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"handleTransitionEnd\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"getIsOpen\",\n    \"docblock\": \"Returns the state of the isOpen prop.\\nIf it is controlled, return the prop value.\\nIf is isn't, use internal state\",\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"state\"\n    }, {\n      \"name\": \"props\"\n    }],\n    \"returns\": null,\n    \"description\": \"Returns the state of the isOpen prop.\\nIf it is controlled, return the prop value.\\nIf is isn't, use internal state\"\n  }, {\n    \"name\": \"toggleIsOpen\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"getTogglerProps\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"props\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"getCollapsibleProps\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"props\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"assignCollapsibleRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": {\n        \"name\": \"HTMLElement\",\n        \"nullable\": true\n      }\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"assignContentRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": {\n        \"name\": \"HTMLElement\",\n        \"nullable\": true\n      }\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"Collapse\",\n  \"props\": {\n    \"isOpen\": {\n      \"defaultValue\": {\n        \"value\": \"null\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"boolean\",\n        \"nullable\": true\n      },\n      \"description\": \"\"\n    },\n    \"defaultOpen\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"boolean\"\n      },\n      \"description\": \"\"\n    },\n    \"collapsedHeight\": {\n      \"defaultValue\": {\n        \"value\": \"0\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"number\"\n      },\n      \"description\": \"\"\n    },\n    \"duration\": {\n      \"defaultValue\": {\n        \"value\": \"1000\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"number\"\n      },\n      \"description\": \"\"\n    },\n    \"delay\": {\n      \"defaultValue\": {\n        \"value\": \"0\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"number\"\n      },\n      \"description\": \"\"\n    },\n    \"easing\": {\n      \"defaultValue\": {\n        \"value\": \"'ease'\",\n        \"computed\": false\n      },\n      \"required\": false,\n      \"flowType\": {\n        \"name\": \"string\"\n      },\n      \"description\": \"\"\n    },\n    \"shouldUseTransitions\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"required\": false\n    },\n    \"children\": {\n      \"required\": true,\n      \"flowType\": {\n        \"name\": \"signature\",\n        \"type\": \"function\",\n        \"raw\": \"({\\n  isOpen: boolean,\\n  getTogglerProps: (*) => {},\\n  getCollapsibleProps: getCollapsibleProps => {},\\n  contentRef: Ref<*>\\n}) => Node\",\n        \"signature\": {\n          \"arguments\": [{\n            \"name\": \"\",\n            \"type\": {\n              \"name\": \"signature\",\n              \"type\": \"object\",\n              \"raw\": \"{\\n  isOpen: boolean,\\n  getTogglerProps: (*) => {},\\n  getCollapsibleProps: getCollapsibleProps => {},\\n  contentRef: Ref<*>\\n}\",\n              \"signature\": {\n                \"properties\": [{\n                  \"key\": \"isOpen\",\n                  \"value\": {\n                    \"name\": \"boolean\",\n                    \"required\": true\n                  }\n                }, {\n                  \"key\": \"getTogglerProps\",\n                  \"value\": {\n                    \"name\": \"signature\",\n                    \"type\": \"function\",\n                    \"raw\": \"(*) => {}\",\n                    \"signature\": {\n                      \"arguments\": [{\n                        \"name\": \"\",\n                        \"type\": {\n                          \"name\": \"unknown\"\n                        }\n                      }],\n                      \"return\": {\n                        \"name\": \"signature\",\n                        \"type\": \"object\",\n                        \"raw\": \"{}\",\n                        \"signature\": {\n                          \"properties\": []\n                        }\n                      }\n                    },\n                    \"required\": true\n                  }\n                }, {\n                  \"key\": \"getCollapsibleProps\",\n                  \"value\": {\n                    \"name\": \"signature\",\n                    \"type\": \"function\",\n                    \"raw\": \"getCollapsibleProps => {}\",\n                    \"signature\": {\n                      \"arguments\": [{\n                        \"name\": \"\",\n                        \"type\": {\n                          \"name\": \"signature\",\n                          \"type\": \"object\",\n                          \"raw\": \"{\\n  refKey: string\\n}\",\n                          \"signature\": {\n                            \"properties\": [{\n                              \"key\": \"refKey\",\n                              \"value\": {\n                                \"name\": \"string\",\n                                \"required\": true\n                              }\n                            }]\n                          }\n                        }\n                      }],\n                      \"return\": {\n                        \"name\": \"signature\",\n                        \"type\": \"object\",\n                        \"raw\": \"{}\",\n                        \"signature\": {\n                          \"properties\": []\n                        }\n                      }\n                    },\n                    \"required\": true\n                  }\n                }, {\n                  \"key\": \"contentRef\",\n                  \"value\": {\n                    \"name\": \"Ref\",\n                    \"elements\": [{\n                      \"name\": \"unknown\"\n                    }],\n                    \"raw\": \"Ref<*>\",\n                    \"required\": true\n                  }\n                }]\n              }\n            }\n          }],\n          \"return\": {\n            \"name\": \"Node\"\n          }\n        }\n      },\n      \"description\": \"\"\n    }\n  }\n};",{"version":3,"sources":["/Users/rfarrer/repos/collapse/src/Collapse.js"],"names":["PureComponent","RAF","callAll","fns","args","forEach","fn","startAnimationHelper","callback","requestAnimationFrame","Collapse","styles","isOpen","getIsOpen","props","defaultOpen","isOpening","counter","delay","duration","isCurrentlyOpen","height","getCollapsibleHeight","Promise","resolve","then","setStyles","setState","overflow","display","collapsible","scrollHeight","newStyles","check","Object","keys","some","key","newStyle","style","includes","state","prevState","onClick","id","Boolean","tabIndex","toggleIsOpen","refKey","console","log","others","assignCollapsibleRef","handleTransitionEnd","transition","easing","node","content","prevProps","children","getTogglerProps","getCollapsibleProps","collapsedHeight","shouldUseTransitions"],"mappings":"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","sourcesContent":["// @flow\n\nimport {PureComponent, type Node, type Ref} from 'react';\nimport RAF from 'raf';\n\n// Helper function for render props. Sets a function to be called, plus any additional functions passed in\nconst callAll = (...fns) => (...args: Array<*>) =>\n  fns.forEach(fn => fn && fn(...args));\n\ntype getCollapsibleProps = {\n  refKey: string\n};\n\ntype Props = {\n  children: ({\n    isOpen: boolean,\n    getTogglerProps: (*) => {},\n    getCollapsibleProps: getCollapsibleProps => {},\n    contentRef: Ref<*>\n  }) => Node,\n  isOpen: ?boolean,\n  defaultOpen: boolean,\n  collapsedHeight: number,\n  duration: number,\n  easing: string,\n  delay: number\n};\n\ntype Styles = {\n  height?: number | string,\n  overflow?: string,\n  display?: string\n};\n\ntype State = {\n  styles: Styles,\n  isOpen: ?boolean,\n  counter: number\n};\n\n// Start animation helper using nested requestAnimationFrames\nconst startAnimationHelper = (callback: () => {}) => {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      callback();\n    });\n  });\n};\n\nexport default class Collapse extends PureComponent<Props, State> {\n  static defaultProps = {\n    isOpen: null,\n    defaultOpen: false,\n    collapsedHeight: 0,\n    duration: 1000,\n    delay: 0,\n    easing: 'ease',\n    shouldUseTransitions: false\n  };\n\n  static counter = 0;\n\n  state = {\n    // height: this.props.collapsedHeight,\n    // overflow: this.getIsOpen({isOpen: this.props.defaultOpen}) ? '' : 'hidden',\n    styles: {\n      // display: 'block',\n      // height: 'auto',\n      // overflow: 'visible'\n    },\n    isOpen: this.getIsOpen({isOpen: this.props.defaultOpen}),\n    isOpening: null,\n    counter: 0\n  };\n\n  componentDidMount() {\n    // Iterate counter to create unique IDs for each instance of this component\n    // on the page. Used mainly for `aria-` relationships\n    this.setState({counter: Collapse.counter++});\n\n    // If open by default, update the height\n    // this.transition();\n  }\n\n  // componentDidUpdate(prevProps: Props, prevState: State) {\n  //   const {delay, duration} = this.props;\n  //   const isCurrentlyOpen = this.getIsOpen();\n  //   // Check if 'height' prop has changed\n  //   if (\n  //     this.content &&\n  //     this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen\n  //   ) {\n  //     // Cache content height\n  //     var style = window.getComputedStyle(this.content);\n  //     var marginTop = style.getPropertyValue('margin-top');\n  //     var marginBottom = style.getPropertyValue('margin-bottom');\n  //     const contentHeight =\n  //       this.content.offsetHeight +\n  //       parseInt(marginTop.split('p')[0], 10) +\n  //       parseInt(marginBottom.split('p')[0], 10);\n\n  //     // set total animation time\n  //     const totalDuration = duration + delay;\n\n  //     let newHeight = null;\n  //     const timeoutState = {\n  //       height: null // it will be always set to either 'auto' or specific number\n  //     };\n  //     const isCurrentHeightAuto = prevState.height === 'auto';\n\n  //     if (isCurrentlyOpen) {\n  //       // If new height is a number\n  //       newHeight = 0;\n  //       timeoutState.height = newHeight;\n  //     } else {\n  //       // If not, animate to content height\n  //       // and then reset to auto\n  //       newHeight = contentHeight;\n  //       timeoutState.height = 'auto';\n  //     }\n\n  //     if (isCurrentHeightAuto) {\n  //       // This is the height to be animated to\n  //       timeoutState.height = newHeight;\n\n  //       // If previous height was 'auto'\n  //       // set starting height explicitly to be able to use transition\n  //       newHeight = contentHeight;\n  //     }\n\n  //     RAF(() =>\n  //       this.setState({\n  //         height: newHeight\n  //       })\n  //     );\n\n  //     // Clear timeouts\n  //     console.log(timeoutState);\n\n  //     if (isCurrentHeightAuto) {\n  //       RAF(() => {\n  //         this.setState(timeoutState);\n  //       });\n  //     } else {\n  //       clearTimeout(this.timeoutID);\n  //       this.timeoutID = setTimeout(() => {\n  //         RAF(() => this.setState(timeoutState));\n  //       }, totalDuration);\n  //     }\n  //   }\n  // }\n\n  componentDidUpdate(prevProps: Props, prevState: State) {\n    const isCurrentlyOpen = this.getIsOpen();\n    // Check if 'height' prop has changed\n    // if (\n    //   this.collapsible &&\n    //   this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen\n    // ) {\n    //   debugger;\n    //   this.setState({isOpening: 'opening'});\n    // } else {\n    //   debugger;\n    //   this.setState({isOpening: 'closing'});\n    // }\n    if (\n      this.collapsible &&\n      this.getIsOpen(prevState, prevProps) !== isCurrentlyOpen\n    ) {\n      this.transition();\n    }\n  }\n\n  // getTransitionDimensions = () => {\n  //   // Cache content height\n  //   const style = window.getComputedStyle(this.content);\n  //   const marginTop = style.getPropertyValue('margin-top');\n  //   const marginBottom = style.getPropertyValue('margin-bottom');\n  //   const contentHeight =\n  //     this.content.offsetHeight +\n  //     parseInt(marginTop.split('p')[0], 10) +\n  //     parseInt(marginBottom.split('p')[0], 10);\n\n  //   return {\n  //     contentHeight,\n  //     totalDuration: this.props.delay + this.props.duration\n  //   };\n  // };\n\n  transition = () => {\n    // Determine current state - closing or opening\n    // If opening to 'auto'\n    const {delay, duration} = this.props;\n    const isCurrentlyOpen = this.getIsOpen();\n\n    if (isCurrentlyOpen) {\n      // Animate closed\n      const height = this.getCollapsibleHeight();\n      return Promise.resolve().then(() => {\n        return this.setStyles({height}).then(() => {\n          this.setState({isOpening: 'closing'});\n          debugger;\n          return RAF(() => this.setStyles({height: 0, overflow: 'hidden'}));\n        });\n      });\n    } else {\n      // Animate open\n      return Promise.resolve().then(() => {\n        return this.setStyles({display: 'block', overflow: 'hidden'}).then(\n          () => {\n            const height = this.getCollapsibleHeight();\n            this.setState({isOpening: 'opening'});\n            return this.setStyles({height});\n          }\n        );\n      });\n    }\n  };\n\n  getCollapsibleHeight = () => {\n    if (!this.collapsible) {\n      return 'auto';\n    }\n    return this.collapsible.scrollHeight;\n  };\n\n  measure = () => {\n    const isCurrentlyOpen = this.getIsOpen();\n    // If closed, styles should be {overflow: 'hidden', display: 'none', height: 0}\n    if (!isCurrentlyOpen) {\n      this.setStyles({display: 'block', overflow: 'hidden'}).then(() => {\n        const height = this.getCollapsibleHeight();\n        this.setStyles({height});\n      });\n    }\n  };\n\n  setStyles = (newStyles: Styles) => {\n    return new Promise<any>(resolve => {\n      const check = () => {\n        this.setState(\n          ({styles}) => ({styles: {...styles, ...newStyles}}),\n          () => {\n            RAF(() => {\n              if (\n                Object.keys(newStyles).some(key => {\n                  let newStyle = newStyles[key];\n                  if (\n                    this.collapsible &&\n                    this.collapsible.style[key].includes('px')\n                  ) {\n                    newStyle =\n                      newStyles[key] || newStyles[key] === 0\n                        ? `${newStyles[key]}px`\n                        : '';\n                  }\n                  return (\n                    !this.collapsible ||\n                    this.collapsible.style[key] !== newStyle\n                  );\n                })\n              ) {\n                return check();\n              }\n              resolve();\n            });\n          }\n        );\n      };\n      check();\n    });\n  };\n\n  handleTransitionEnd = () => {\n    if (this.state.isOpening === 'opening') {\n      debugger;\n      this.setState(prevState => ({\n        isOpening: null,\n        styles: {\n          ...prevState.styles,\n          display: '',\n          overflow: '',\n          height: 'auto'\n        }\n      }));\n    }\n    if (this.state.isOpening === 'closing') {\n      debugger;\n      this.setState(prevState => ({\n        isOpening: null,\n        styles: {\n          ...prevState.styles,\n          display: 'none'\n        }\n      }));\n    }\n  };\n\n  collapsible: ?HTMLElement;\n  content: ?HTMLElement;\n  timeoutID: TimeoutID;\n\n  /**\n   * Returns the state of the isOpen prop.\n   * If it is controlled, return the prop value.\n   * If is isn't, use internal state\n   */\n  getIsOpen(\n    state: $Shape<State> = this.state,\n    props: $Shape<Props> = this.props\n  ) {\n    return props.isOpen !== null ? props.isOpen : state.isOpen;\n  }\n\n  toggleIsOpen = () => this.setState(({isOpen}) => ({isOpen: !isOpen}));\n\n  getTogglerProps = (props: {onClick: ?() => void} = {onClick() {}}) => {\n    return {\n      id: `CollapseToggle-${this.state.counter}`,\n      'aria-controls': `CollapsePanel-${this.state.counter}`,\n      'aria-expanded': Boolean(this.getIsOpen()),\n      tabIndex: 0,\n      ...props,\n      onClick: callAll(props.onClick, this.toggleIsOpen)\n    };\n  };\n\n  // For those with a hard time reading Flow, this destructures refKey off of props,\n  // and gives it a default of 'ref'\n  getCollapsibleProps = (props: getCollapsibleProps = {refKey: 'ref'}) => {\n    console.log(props);\n    const {refKey, ...others} = props;\n    debugger;\n    return {\n      id: `CollapsePanel-${this.state.counter}`,\n      'aria-hidden': Boolean(this.getIsOpen()),\n      ...others,\n      [refKey]: callAll(this.assignCollapsibleRef, others[refKey]),\n      onTransitionEnd: this.handleTransitionEnd,\n      style: {\n        // @TODO: throw a warning if they pass in properties that might conflict with the animation\n        // ...props.style,\n        ...this.state.styles,\n        transition: `height ${this.props.duration}ms ${this.props.easing} ${\n          this.props.delay\n        }ms`\n      }\n    };\n  };\n\n  assignCollapsibleRef = (node: ?HTMLElement) => (this.collapsible = node);\n\n  assignContentRef = (node: ?HTMLElement) => (this.content = node);\n\n  render() {\n    console.log(this.state.styles);\n    return this.props.children({\n      isOpen: Boolean(this.getIsOpen()),\n      getTogglerProps: this.getTogglerProps,\n      getCollapsibleProps: this.getCollapsibleProps\n    });\n  }\n}\n"]}]}